---
tags: ["Research", "Generative AI", "Applications"]
date: 2026-01-26
author: "Dario Ferrero"
---

# Repetita Iuvant: cómo repetir el prompt duplica el rendimiento de los LLM
![prompt-repetition.jpg](prompt-repetition.jpg)

***Repetita iuvant**, decían los latinos. Las cosas repetidas ayudan. ¿Y si esta máxima, con dos mil años de antigüedad, resultara ser también la heurística computacional más eficiente para los modelos de lenguaje más avanzados de 2026? Eso es lo que se desprende de [un artículo publicado por Google Research](https://arxiv.org/html/2512.14982v1) en enero, donde tres investigadores, Yaniv Leviathan, Matan Kalman y Yossi Matias, descubrieron algo desconcertante en su simplicidad: basta con repetir dos veces el mismo prompt para mejorar significativamente el rendimiento de GPT, Claude, Gemini y Deepseek. Nada de elaboradas cadenas de pensamiento, nada de sofisticada ingeniería de prompts. Literalmente: copiar, pegar.*

La técnica funciona así: en lugar de someter al modelo una consulta en la forma clásica `<QUERY>`, se transforma en `<QUERY><QUERY>`. Fin. Y, sin embargo, los resultados son cualquier cosa menos triviales. En las pruebas realizadas con siete modelos de vanguardia y otros tantos benchmarks, [la repetición del prompt ganó 47 de 70 pruebas](https://arxiv.org/html/2512.14982v1#S2), con cero derrotas. En algunas tareas personalizadas creadas ad hoc por los investigadores, las mejoras rozan lo surrealista: Gemini 2.0 Flash-Lite pasa del 21,33% al 97,33% de precisión en el benchmark NameIndex. Un salto de setenta y seis puntos porcentuales obtenido duplicando el texto.

## Cuando mirar hacia adelante significa no ver hacia atrás

Para entender por qué funciona esta técnica, es necesario dar un paso atrás en la arquitectura de los grandes modelos de lenguaje. La inmensa mayoría de los LLM modernos se entrenan como *modelos de lenguaje causal*, un término técnico que esconde una restricción estructural fundamental: cada token solo puede "ver" los tokens que lo preceden, nunca los que le siguen. Es como leer un libro con una ventana móvil que cubre todo lo que está por delante de la palabra actual.

Este mecanismo de [atención causal](https://arxiv.org/html/2512.14982v1#S1), por muy eficiente que sea durante el entrenamiento, introduce un problema sutil pero generalizado: el orden de la información en el prompt importa, y mucho. Un ejemplo concreto ayuda a visualizarlo. Imaginen una pregunta de opción múltiple estructurada así: primero la pregunta, luego las opciones de respuesta. Cuando el modelo lee las opciones, ya ha procesado la pregunta y puede contextualizarlas. Pero si se invierte el orden, primero las opciones y luego la pregunta, el modelo procesa las respuestas *antes* de saber qué se le está preguntando. ¿El resultado? Un rendimiento sistemáticamente peor.

Los investigadores de Google probaron ambas configuraciones en los benchmarks ARC, OpenBookQA y MMLU-Pro. Con el formato clásico de pregunta primero, las mejoras de la repetición del prompt fueron modestas. Pero con el formato de opciones primero, en el que el modelo ve las respuestas sin conocer aún la pregunta, [las ganancias fueron sustanciales](https://arxiv.org/html/2512.14982v1#S1.F1). La repetición del prompt permite que cada token "vea" todos los demás tokens del prompt, eludiendo la restricción causal. No es una verdadera atención bidireccional, pero simula sus efectos.

## La solución desarmante

La belleza de la repetición del prompt reside en su simplicidad operativa. No requiere modificaciones en los modelos, no cambia el formato de las respuestas, no aumenta el número de tokens generados ni la latencia percibida. Es lo que en la jerga se conoce como *despliegue directo*: se toma el sistema existente, se añade una línea de código que duplica el prompt y se obtienen mejoras medibles. Para los usuarios finales, es aún más inmediato: basta con copiar y pegar la pregunta dos veces.

Las pruebas se realizaron entre febrero y marzo de 2025 a través de las API oficiales de cuatro proveedores principales. De Google: [Gemini 2.0 Flash y Gemini 2.0 Flash Lite](https://arxiv.org/html/2512.14982v1#bib.bib5). De OpenAI: [GPT-4o y GPT-4o-mini](https://arxiv.org/html/2512.14982v1#bib.bib12). De Anthropic: [Claude 3 Haiku y Claude 3.7 Sonnet](https://arxiv.org/html/2512.14982v1#bib.bib1). Y finalmente [Deepseek V3](https://arxiv.org/html/2512.14982v1#bib.bib4). Siete modelos de diferentes tamaños y capacidades, todos probados en benchmarks consolidados como GSM8K para matemáticas, MATH para problemas más complejos y los ya mencionados conjuntos de datos de comprensión de texto.

Además de los benchmarks estándar, los investigadores crearon dos tareas diseñadas específicamente para resaltar las limitaciones de la atención causal. La primera, NameIndex, es de una simplicidad desarmante: se le proporciona al modelo una lista de cincuenta nombres y se le pide que devuelva el vigésimo quinto. Parece trivial, pero requiere hacer un seguimiento de la posición mientras se procesan secuencialmente todos los nombres anteriores. La segunda, MiddleMatch, pide identificar el nombre que aparece exactamente entre dos nombres específicos en una lista de cuarenta elementos con repeticiones. Son tareas que un humano resolvería en pocos segundos ojeando, pero que para un modelo causal representan un desafío computacional no trivial.

[Los resultados en estas tareas](https://arxiv.org/html/2512.14982v1#A1.SS3) muestran la brecha más clara. En NameIndex, Gemini Flash-Lite sin repetición obtiene apenas un 21,33% de respuestas correctas. Con la simple repetición del prompt: 97,33%. GPT-4o pasa del 92% al 100%. Claude 3.7 Sonnet del 98,67% al 100%. No son incrementos marginales, son saltos cualitativos que convierten tareas imposibles en resueltas.

Los investigadores también probaron variantes de la técnica básica. La *Repetición Verbosa del Prompt* introduce una frase de transición: `<QUERY> Déjame repetir eso: <QUERY>`. La *Repetición del Prompt ×3* triplica el prompt con dos frases de conexión. [Ambas variantes](https://arxiv.org/html/2512.14982v1#A1.SS1) obtienen resultados comparables a la repetición simple en la mayoría de los benchmarks, con mejoras adicionales ocasionales en las tareas personalizadas. Para excluir que los beneficios se debieran simplemente al aumento de la longitud del prompt, también se probó un método de control llamado *Relleno*, que añade puntos de relleno hasta alcanzar la misma longitud que la repetición. Como era de esperar, el relleno no produjo ninguna mejora.

## Bajo el capó

La clave de la eficiencia reside en la forma en que los transformadores procesan el texto. La generación de una respuesta se divide en dos fases: el *prellenado*, donde el modelo procesa todo el prompt en paralelo construyendo la caché KV, y la *decodificación*, donde genera los tokens uno a uno de forma secuencial. La repetición del prompt solo afecta al prellenado, que ya está paralelizado y, por tanto, es extremadamente rápido. La generación propiamente dicha, la parte lenta, no cambia en absoluto.

[Las mediciones empíricas](https://arxiv.org/html/2512.14982v1#S2.SS0.SSS0.Px3) lo confirman: no hay un aumento significativo de la latencia en la mayoría de los modelos. La excepción son los modelos de Anthropic, Claude Haiku y Claude 3.7 Sonnet, cuando se prueban con prompts muy largos como los de las tareas NameIndex y MiddleMatch, o con la variante ×3. En estos casos, la latencia aumenta, probablemente porque la fase de prellenado empieza a pesar. Pero para prompts de longitud normal, la sobrecarga es insignificante.

Aún más interesante: el número de tokens generados permanece idéntico. A diferencia de técnicas como el famoso ["Piensa paso a paso"](https://arxiv.org/abs/2205.11916) propuesto por Kojima en 2023, que mejora el razonamiento pero genera respuestas mucho más largas, la repetición del prompt no altera en absoluto la salida. El modelo responde con el mismo formato, la misma longitud, las mismas palabras. Solo cambia la precisión. Esto la hace compatible con cualquier sistema existente que espere respuestas en un formato específico.

La comparación con la Cadena de Pensamiento es esclarecedora. El CoT y sus variantes obligan al modelo a explicitar el razonamiento, aumentando drásticamente tanto los tokens generados como la latencia. Funcionan muy bien para tareas de razonamiento complejo, pero tienen un coste computacional significativo. La repetición del prompt ocupa un nicho diferente: [tareas de comprensión, clasificación, respuesta a preguntas directas](https://arxiv.org/html/2512.14982v1#S1), todo aquello que no requiere un razonamiento elaborado pero donde el orden de la información puede crear confusión.

Y, de hecho, cuando los investigadores probaron la repetición del prompt en combinación con la instrucción "piensa paso a paso", [los resultados fueron neutros o ligeramente positivos](https://arxiv.org/html/2512.14982v1#A1.SS2): cinco victorias, una derrota, veintidós empates. Tiene sentido: si el modelo ya está razonando y explicitando su proceso, probablemente ya repite las partes relevantes del prompt en su razonamiento interno. La técnica se vuelve redundante.
![grafici.jpg](grafici.jpg)
[Imagen de arxiv.org](https://arxiv.org/html/2512.14982v1)

## Aplicaciones y limitaciones

El artículo se publicó en enero de 2026 y la recepción en la comunidad técnica fue rápida. En Reddit, en el subreddit LocalLLaMA dedicado a los modelos de lenguaje locales, varios usuarios compartieron experimentos prácticos. Los resultados confirman lo reportado en el artículo, y algunos señalan mejoras notables en tareas de clasificación y extracción de información. Otros han notado beneficios particulares en modelos más pequeños, los de menos de 10 mil millones de parámetros, donde la repetición del prompt parece compensar parcialmente las limitaciones arquitectónicas.

Los casos de uso ideales surgen con bastante claridad del artículo y de las discusiones posteriores. Clasificación de texto, donde hay que asignar categorías basándose en información dispersa en el prompt. Preguntas de opción múltiple, especialmente cuando las opciones son largas o complejas. Extracción de información específica de contextos largos. Cualquier tarea en la que el orden de presentación de la información pueda crear ambigüedad para un modelo causal.

Las limitaciones son igualmente claras. En primer lugar: solo funciona sin un razonamiento explícito. Si está utilizando GPT-5 o Claude Opus para resolver problemas matemáticos complejos o para programar, la repetición del prompt probablemente no le dará ninguna ventaja. En segundo lugar: en prompts ya muy largos, piense en los de 8000-10000 tokens, duplicar el texto puede empezar a crear problemas de latencia, especialmente con ciertos proveedores. En tercer lugar: [algunos modelos de Anthropic muestran aumentos de latencia](https://arxiv.org/html/2512.14982v1#S2.SS0.SSS0.Px3) incluso con prompts moderadamente largos cuando se utiliza la repetición.

Pero quizás la limitación más interesante es epistemológica. Todavía no sabemos exactamente *por qué* funciona tan bien. El artículo ofrece una explicación mecanicista sólida, la atención pseudobidireccional, pero los detalles de cómo los modelos utilizan realmente esta información duplicada siguen siendo opacos. Los investigadores sugieren como dirección futura [analizar los patrones de atención](https://arxiv.org/html/2512.14982v1#S4) durante la repetición, para entender qué partes del prompt duplicado reciben más peso y cuándo.

## Una genealogía de la repetición

La repetición del prompt no surge de la nada. Se inscribe en una línea de investigación más amplia sobre la manipulación estratégica de las entradas de los LLM. El punto de referencia histórico es el ya mencionado prompting de Cadena de Pensamiento, propuesto por [Wei y sus colegas en 2023](https://arxiv.org/abs/2201.11903), que demostró cómo pedir explícitamente al modelo que razone paso a paso mejora drásticamente el rendimiento en tareas complejas. Kojima refinó luego el enfoque, mostrando que basta con añadir "Piensa paso a paso" para obtener efectos similares, sin necesidad de ejemplos específicos para cada tarea.

Pero también existen exploraciones más directas de la repetición. [Sagi Shaier publicó en diciembre de 2024](https://arxiv.org/abs/2412.07923) un estudio sobre la robustez de los LLM cuando se repiten las *preguntas*, no todo el prompt, solo la parte interrogativa. Sus resultados muestran que repetir solo la pregunta no produce mejoras significativas, y a veces incluso empeora ligeramente el rendimiento. Es un contraste interesante con los resultados de Google: evidentemente, es importante repetir *todo* el contexto, no solo la consulta.

Otra línea de investigación relacionada proviene de [Jacob Springer y sus colegas](https://arxiv.org/abs/2402.15449), quienes en febrero de 2024 demostraron que repetir la entrada dos veces mejora la calidad de las incrustaciones de texto. Las incrustaciones son representaciones vectoriales del texto utilizadas para tareas de similitud semántica, y el hecho de que la repetición también ayude ahí sugiere que los beneficios van más allá de la simple generación de respuestas.

Aún más cercano al trabajo de Google es [el estudio de Xiaohan Xu de 2024](https://arxiv.org/abs/2309.06275), que exploró la *relectura*: pedir explícitamente al modelo que relea la pregunta antes de responder. Xu descubrió que la relectura mejora el razonamiento, pero con un mecanismo diferente: el modelo genera efectivamente una repetición en su salida, aumentando los tokens producidos y la latencia. La repetición del prompt obtiene efectos similares al trasladar el coste a la fase de prellenado.

Lo que se desprende de esta constelación de investigaciones es un patrón: los modelos de lenguaje se benefician de procesar la misma información varias veces, pero *cómo* y *cuándo* se produce este reprocesamiento marca toda la diferencia. Repetir en el prompt es eficiente, repetir en la salida es costoso y repetir solo partes seleccionadas es ineficaz.

## Más allá del artículo

Las direcciones futuras propuestas por los investigadores de Google son ambiciosas. Una de las más interesantes se refiere al ajuste fino: ¿y si entrenáramos modelos específicamente con prompts repetidos? Podrían aprender a explotar mejor esta estructura, quizás desarrollando patrones de atención optimizados. O, paradójicamente, podrían aprender a *no* repetir en su salida, haciendo la técnica aún más eficiente.

Otra dirección toca la optimización de la caché KV. Actualmente, cuando se repite el prompt, ambas copias se guardan en la caché. Pero técnicamente bastaría con mantener solo la segunda repetición, la que ha "visto" todos los tokens. [Esto haría que la técnica fuera completamente neutral](https://arxiv.org/html/2512.14982v1#S4) incluso para la fase de generación, eliminando cualquier sobrecarga de memoria.

Luego está la cuestión de la multimodalidad. Los modelos modernos procesan texto, imágenes, audio. ¿Tiene sentido repetir también las entradas no textuales? Y si es así, ¿cómo? Repetir una imagen píxel por píxel parece inútil, pero quizás existan formas más inteligentes de "repetir" la información visual para permitir que las diferentes partes de una imagen se "vean" mejor entre sí.

La versión más radical de la técnica podría implicar repeticiones dinámicas durante la propia generación. En lugar de repetir solo el prompt inicial, también se podrían repetir periódicamente los tokens ya generados, permitiendo que el modelo reprocese su salida mientras la produce. Es especulativo, pero el artículo lo menciona como una posibilidad.

En el plano práctico, la pregunta es: ¿alguien la está utilizando realmente en producción? Los investigadores probaron todos los principales modelos comerciales, lo que sugiere un interés en la aplicabilidad en el mundo real. Y algunos comentarios en foros técnicos indican que los desarrolladores están experimentando con la técnica en pipelines de clasificación y análisis de sentimientos. Pero todavía falta una adopción masiva documentada, probablemente porque el artículo es muy reciente.

Una reflexión final sobre la simplicidad. En un campo dominado por arquitecturas cada vez más complejas, mezcla de expertos, generación aumentada por recuperación, marcos de agentes multimodales, hay algo paradójicamente revolucionario en una técnica que consiste literalmente en pulsar Ctrl+C y Ctrl+V. Es un recordatorio de que la innovación no siempre proviene de la complejidad añadida, sino a veces de una comprensión más profunda de las restricciones existentes. La atención causal es una limitación arquitectónica conocida desde hace años. La repetición del prompt es simplemente la forma más obvia de sortearla, una vez que se piensa en ello. Como los patrones minimalistas de Steve Reich, donde la repetición estratégica de frases musicales crea una complejidad emergente, aquí la duplicación del texto genera una forma de comprensión que el modelo no podría obtener de otro modo.

Los latinos ya lo sabían: *repetita iuvant*. Los investigadores de Google solo han traducido el concepto a una técnica computacional. Y funciona.
